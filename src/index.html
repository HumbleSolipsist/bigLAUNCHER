<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>bigLAUNCHER</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div id="buttons">
      <button file="/usr/bin/gedit">gedit</button>
      <button file="/usr/bin/qdirstat">qdirstat</button>
      <button file="/usr/bin/nautilus">nautilus</button>
      <button file="/usr/bin/gedit">gedit</button>
      <button file="/usr/bin/qdirstat">qdirstat</button>
      <button file="/usr/bin/nautilus">nautilus</button>
      <button file="/usr/bin/gedit">gedit</button>
      <button file="/usr/bin/qdirstat">qdirstat</button>
      <button file="/usr/bin/nautilus">nautilus</button>
      <button file="/usr/bin/gedit" immortal> immortal gedit</button>
      <button file="/usr/bin/qdirstat">qdirstat</button>
      <button file="/usr/bin/nautilus">nautilus</button>
    </div>
    <p>(Select with the d-pad, start with A)</p>
  </body>

  <script>
    // facilitates communication with the main process
    const { ipcRenderer } = require("electron")

    const buttonContainer = document.getElementById('buttons')
    const buttons = Array.from(buttonContainer.children)

    const second = 1000;
    const timeout = second * 5;

    // Stores UNIX timestamp (in ms) of last gamepad input
    let lastInput = Date.now()

    // Start polling a gamepad when it connects
    window.addEventListener("gamepadconnected", (e) => {
      // make sure no fake game pads are being used
      if (e.gamepad.buttons.length < 14) return;

      console.log(
        "Gamepad connected at index %d: %s. %d buttons, %d axes.",
        e.gamepad.index,
        e.gamepad.id,
        e.gamepad.buttons.length,
        e.gamepad.axes.length,
      );

      const gIndex = e.gamepad.index
      // Gamepad polling code
      let inputInterval = setInterval(() => {
        const gamepad = navigator.getGamepads()[gIndex]

        // input logging
        /*
        let s = gamepad.id + "\nButtons: "

        gamepad.buttons.forEach((b, i) => {
          s += i + "(" + b.pressed + "," + b.value + ") "
        });

        s += "\nAxes: "
        gamepad.axes.forEach((a, i) => {
          s += i + "(" + a + ") "
        });

        console.log(s)
        */

        // check for inputs to reset time
        if (inputDetected(gamepad)) {
          lastInput = Date.now()
        }

        // check for start & back being pressed as game ending shortcut
        if (gamepad.buttons[8].pressed && 
            gamepad.buttons[9].pressed) {
          ipcRenderer.send("killChild")
        }
        
        // only interact with the menu if this page is focused
        if (document.hasFocus()) {
          menuInteract(gamepad)
        }
        
      }, second/100)

      // stop polling a controller if it disconnects
      window.addEventListener("gamepaddisconnected", (e) => {
        if (e.gamepad.index == gIndex) {
          clearInterval(inputInterval)
        }
      });
    });

    // onclick for buttons
    buttons.forEach(button => {
      button.addEventListener('click', () => {
        ipcRenderer.send('exec', button.getAttribute("file"))
        lastInput = Date.now()
        if (button.getAttribute("immortal") == null)
        {
          startTimeout(timeout)
        }
      });
    });

    // Ends the child process if t milliseconds have passed since last input,
    // else restarts the timer with an appropriate amount of time.
    function startTimeout(t) {
      setTimeout(() => {
        const sinceLastInput = Date.now() - lastInput;
        if (sinceLastInput >= t) {
          ipcRenderer.send("killChild")
        }
        else
        {
          startTimeout(t - sinceLastInput)
        }
      }, t)
    }

    // check for any inputs on the given gamepad
    function inputDetected(gamepad) {
      let output = false

      // check if any buttons are pressed
      output = gamepad.buttons.reduce((acc, cur) => acc || cur.pressed, output)
      // check if joysticks are moved. The 0.1 literal is a deadzone.
      output = gamepad.axes.reduce((acc, cur) => acc || (Math.abs(cur) > 0.1), output)

      return output
    }

    // tracks menu interactions so that they do not happen too rapidly
    let lastA = Date.now()
    let lastUp = Date.now()
    let lastDown = Date.now()

    // set a delay so that the interactions don't happen every frame
    const menuDelay = second/7

    // process inputs to do with menu interaction
    function menuInteract(gamepad) {
      try {
        if (!buttons.reduce(
          (acc, cur) => acc || document.activeElement == cur, false)) {
          buttons[0].focus()
        }

        // when A pressed
        if (gamepad.buttons[0].pressed && Date.now() - lastA >= menuDelay) {
          lastA = Date.now()
          document.activeElement.click()
        }

        // when Up pressed (d-pad)
        if (gamepad.buttons[12].pressed && Date.now() - lastUp >= menuDelay) {
          lastUp = Date.now()
          document.activeElement.previousElementSibling.focus()
        }

        // when Down pressed (d-pad)
        if (gamepad.buttons[13].pressed && Date.now() - lastDown >= menuDelay) {
          lastDown = Date.now()
          document.activeElement.nextElementSibling.focus()
        }
      } catch (error) {}
    }

    ipcRenderer.on("hotkey", () => lastInput = Date.now())
  </script>
</html>
